# instructions.txt (Revision 2 - Addressing Date Type Issue)

## Goal
[source: 1] Convert the existing todo list Hyperware app into a peer-to-peer chat application named "samchat".
[source: 2] Users should be able to enter another user's Hyperware address (e.g., "username.os") and exchange messages.
[source: 3] The application must handle both sending and receiving messages, and persist message history on the backend.

## Important Constraints
* **No Custom WIT Types:** The Hyperware build system does **not** support custom types like "date-time" in WIT definitions. You **must** use standard WIT-compatible types (e.g., `string`, `u64`) in your Rust structs that get exposed via WIT. For timestamps, we will use `string`. The build framework will generate WIT types based on function signatures automatically.
* **Agent Limitations:** Remember, you (Claude Code) are an agent that only writes code based on these instructions. Do **not** run any `kit` commands and do **not** write or run any tests. The user will handle building and testing.
* **File Structure:** Work within the provided `samchat` folder structure [source: 4]. Modify existing files as needed [source: 5].

## Core Framework Concepts (Review `resources/app-framework.md` and `resources/llm-generated-app-guide.md` for details)
* **Backend (`src/lib.rs`):** Uses Rust and the `hyperprocess` macro [source: 6]. State is defined in the struct associated with the macro. Handlers (`#[http]`, `#[remote]`, `#[local]`) define the API [source: 6].
* **Frontend (`ui/src/`):** Uses TypeScript and React/Vite [source: 7]. Communicates with the backend via HTTP requests [source: 9]. State is managed with Zustand [source: 8].
* **Communication:**
    * UI -> Backend: Standard HTTP POST requests to `/api` [source: 9, 112].
    * Backend -> Backend (P2P): Uses `Request::new().target(...).send()` [source: 10]. Incoming P2P messages handled by `#[remote]` [source: 10].
* **Persistence:** Backend state (`SamchatState` struct) saved based on `save_config` [source: 11].

## Step-by-Step Instructions:

### Phase 1: Backend Modifications (`src/lib.rs`)

1.  **Update Metadata and Manifest:**
    * Open `samchat/metadata.json`.
    * Change `"name"` to "Samchat" [source: 12]. Update `"description"` (e.g., "A simple p2p chat application using Hyperware") [source: 12].
    * Open `samchat/pkg/manifest.json`.
    * Ensure `"process_name"` is "samchat" [source: 13]. Verify `"request_networking": true` [source: 14].

2.  **Define Chat Data Structures (Using `String` for Timestamps):**
    * Remove the `TodoItem` struct [source: 16].
    * **Crucially**, add `use chrono::{DateTime, Utc};` at the top, but **only** use `DateTime<Utc>` for *internal logic*. For fields that will be part of the WIT interface (i.e., fields in structs returned by handlers), use `String` to represent timestamps.
    * Define `ChatMessage` using `String` for `timestamp`:
        ```rust
        #[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
        pub struct ChatMessage {
            id: String, // Unique message ID (e.g., UUID)
            conversation_id: String, // Identifier for the chat thread
            sender: String, // Sender's full address
            recipient: String, // Recipient's full address
            content: String, // The message text
            timestamp: String, // << CHANGED: Use String for WIT compatibility
            delivered: bool,
        }
        ```
    * Define `Conversation` using `String` for `last_updated`:
        ```rust
        use std::collections::HashMap; // Ensure HashMap is imported

        #[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
        pub struct Conversation {
            id: String, // Unique ID for the conversation
            participants: Vec<String>, // List of node addresses
            messages: Vec<ChatMessage>, // Chronological list of messages
            last_updated: String, // << CHANGED: Use String for WIT compatibility
        }
        ```
    * Modify `SamchatState` to store conversations [source: 21]:
        ```rust
        #[derive(PartialEq, Clone, Default, Debug, Serialize, Deserialize)]
        pub struct SamchatState {
            conversations: HashMap<String, Conversation>,
            my_node_id: Option<String>,
        }
        ```

3.  **Update `hyperprocess` Macro:**
    * Ensure `name = "samchat"` [source: 23].
    * Keep `ui = Some(HttpBindingConfig::default())` [source: 23].
    * Ensure `endpoints` includes `/api` for HTTP and `/ws` if needed (though `/ws` might not be used by current handlers) [source: 24].
    * Set `save_config = SaveOptions::EveryMessage` [source: 25].
    * Set `wit_world = "samchat-template-dot-os-v0"` (or similar) [source: 26].

4.  **Implement Initialization:**
    * Modify the `#[init]` function `initialize` [source: 27]:
        ```rust
        use hyperware_process_lib::{our, Address, PackageId, ProcessId}; // Make sure these are imported [source: 29]
        use std::collections::HashMap; // Ensure HashMap is imported

        #[init]
        async fn initialize(&mut self) {
            println!("Initializing Samchat state...");
            self.conversations = HashMap::new(); // [source: 30]
            self.my_node_id = Some(our().node.clone()); // Store own node ID [source: 31]
            println!("Samchat initialized for node: {:?}", self.my_node_id);
        }
        ```

5.  **Remove Todo-Specific Handlers:**
    * Delete `add_task`, `get_tasks`, `toggle_task`, `export_state`, `import_state` methods [source: 32].

6.  **Implement Chat Handlers (Using `String` Timestamps):**
    * **`SendMessage` (`#[http]` Handler):**
        * Accept `recipient_address: String`, `message_content: String` [source: 34].
        * Get sender address from `self.my_node_id` [source: 45]. Validate inputs [source: 46, 47, 48].
        * Determine `conversation_id` (e.g., sort sender/recipient and join) [source: 49].
        * Create `ChatMessage`: Use `Uuid::new_v4().to_string()` for `id` [source: 50]. **Convert `Utc::now()` to a string** using `to_rfc3339()` for the `timestamp` field [source: 50].
        * Persist locally: Add the message to `self.conversations` [source: 41]. **Convert `Utc::now()` to a string** using `to_rfc3339()` for `last_updated` when creating/updating a `Conversation` [source: 52].
        * Construct target `Address` [source: 35, 54]. **Use the publisher from `metadata.json`** when constructing the `ProcessId` string, like `format!("samchat:samchat:{}", metadata.properties.publisher).parse()?` [source: 54].
        * Define `RequestType` enum wrapping `ChatMessage` [source: 38, 44].
        * Serialize the `RequestType` [source: 56].
        * Send the request using `Request::new().target(...).body(...).send()` (fire-and-forget) [source: 39, 57, 58]. Handle potential send errors [source: 60].
        * Return `Result<(), String>` [source: 43].

        ```rust
        // Add these imports at the top if not already present
        use chrono::{DateTime, Utc};
        use uuid::Uuid;
        use hyperware_process_lib::{our, Address, Request, PackageId, ProcessId}; // [source: 29]
        use std::collections::HashMap;
        use serde::{Deserialize, Serialize};

        // Define request/response types for messaging [source: 44]
        #[derive(Serialize, Deserialize, Debug)]
        enum RequestType {
            ReceiveMessage(ChatMessage),
        }
        #[derive(Serialize, Deserialize, Debug)]
        enum ResponseType {
            Ack,
        }

        // --- Handler Implementation ---
        #[http]
        async fn send_message(&mut self, recipient_address: String, message_content: String) -> Result<(), String> {
            println!("send_message called: to={}, content='{}'", recipient_address, message_content);
            let sender_address = self.my_node_id.clone().ok_or_else(|| "Sender node ID not initialized".to_string())?;

            if recipient_address.trim().is_empty() || message_content.trim().is_empty() { // [source: 46]
                return Err("Recipient address and message content cannot be empty".to_string()); // [source: 47]
            }
            if !recipient_address.contains('.') { // [source: 48]
                return Err("Invalid recipient address format (e.g., 'username.os')".to_string()); // [source: 48]
            }

            let mut participants = vec![sender_address.clone(), recipient_address.clone()];
            participants.sort(); // [source: 49]
            let conversation_id = participants.join("|"); // [source: 49]

            let message = ChatMessage {
                id: Uuid::new_v4().to_string(), // [source: 50]
                conversation_id: conversation_id.clone(),
                sender: sender_address.clone(),
                recipient: recipient_address.clone(),
                content: message_content,
                timestamp: Utc::now().to_rfc3339(), // << CHANGED: Convert to string [source: 50]
                delivered: false,
            };

            let current_time_str = Utc::now().to_rfc3339(); // Convert current time to string once

            let conversation = self.conversations.entry(conversation_id.clone()).or_insert_with(|| Conversation { // [source: 52]
                id: conversation_id.clone(),
                participants: participants.clone(),
                messages: Vec::new(),
                last_updated: current_time_str.clone(), // << Use string timestamp [source: 52]
            });
            conversation.messages.push(message.clone()); // [source: 52]
            conversation.last_updated = current_time_str; // << Update with string timestamp [source: 52]
            println!("Message persisted locally: {}", message.id); // [source: 53]

            // Construct target address - You MUST get the publisher dynamically
            // This requires reading metadata.json at runtime or compile time.
            // For simplicity here, let's assume it's template.os, but remind Claude this might need adjustment.
            let target_process_id_str = format!("samchat:samchat:{}", "template.os"); // Placeholder - ideally read from metadata
             let target_process_id: ProcessId = target_process_id_str.parse().map_err(|e| format!("Failed to parse ProcessId: {}", e))?; // [source: 54]
            let target_address = Address::new(recipient_address.clone(), target_process_id); // [source: 55]

            let request_body = serde_json::to_vec(&RequestType::ReceiveMessage(message.clone()))
                .map_err(|e| format!("Serialization error: {}", e))?; // [source: 56]

            println!("Sending message {} to {}", message.id, target_address);
            let send_result = Request::new()
                .target(target_address)
                .body(request_body)? // [source: 57]
                .send(); // Fire-and-forget [source: 58]

            match send_result {
                Ok(_) => {
                    println!("Message {} sent successfully (no response expected).", message.id); // [source: 59]
                    Ok(())
                },
                Err(e) => {
                    let error_msg = format!("Failed to send message {}: {:?}", message.id, e); // [source: 60]
                    println!("{}", error_msg);
                    Err(error_msg) // [source: 60]
                }
            }
        }
        ```

    * **`ReceiveMessage` (`#[remote]` Handler):**
        * Accept a `ChatMessage` as input [source: 62]. The `timestamp` field will already be a `String`.
        * Persist the received message to `self.conversations` [source: 63]. If creating a new `Conversation`, use the `timestamp` string from the *message* for the initial `last_updated` field [source: 68]. When updating an existing `Conversation`, **convert `Utc::now()` to a string** using `to_rfc3339()` for `last_updated` [source: 72].
        * Avoid duplicates based on message `id` [source: 71]. Sort messages by timestamp string if needed (string comparison might suffice for ISO format, but parsing might be safer if complex sorting is needed) [source: 72].
        * Log reception [source: 64].
        * Return `Result<(), String>` [source: 66, 76].

        ```rust
        #[remote]
        async fn receive_message(&mut self, message: ChatMessage) -> Result<(), String> { // [source: 61]
            println!("receive_message called: from={}, content='{}'", message.sender, message.content); // [source: 67]
            let conversation_id = message.conversation_id.clone();

            let current_time_str = Utc::now().to_rfc3339(); // Convert current time to string

            let conversation = self.conversations.entry(conversation_id.clone()).or_insert_with(|| { // [source: 68]
                 let mut participants = vec![message.sender.clone(), message.recipient.clone()];
                 participants.sort();
                 Conversation {
                    id: conversation_id.clone(),
                    participants: participants,
                    messages: Vec::new(),
                    last_updated: message.timestamp.clone(), // << Use the string timestamp from message [source: 69]
                }
            });

            if !conversation.messages.iter().any(|m| m.id == message.id) { // [source: 71]
                conversation.messages.push(message.clone());
                // Sort messages by timestamp string (lexicographical should work for ISO format)
                 conversation.messages.sort_by(|a, b| a.timestamp.cmp(&b.timestamp)); // [source: 72]
                conversation.last_updated = current_time_str; // << Update with current time as string [source: 72]
                println!("Message {} received and persisted.", message.id); // [source: 73]
            } else {
                 println!("Duplicate message {} received, ignoring.", message.id); // [source: 74]
            }

            Ok(()) // [source: 76]
        }
        ```

    * **`GetConversations` (`#[http]` Handler):**
        * Iterate through `self.conversations` [source: 77].
        * Define `ConversationSummary` struct with `id: String`, `participants: Vec<String>`, `last_updated: String` (<< Use `String`).
        * Return `Result<Vec<ConversationSummary>, String>`. Map `Conversation` to `ConversationSummary`, keeping `last_updated` as a string [source: 78, 81]. Optionally sort by `last_updated` string [source: 82].

        ```rust
        #[derive(Serialize, Deserialize, Debug, Clone)]
        pub struct ConversationSummary { // [source: 79]
            id: String,
            participants: Vec<String>,
            last_updated: String, // << CHANGED: Use String
        }

        #[http]
        async fn get_conversations(&self, _request_body: String) -> Result<Vec<ConversationSummary>, String> { // [source: 80]
             println!("get_conversations called");
             let mut summaries: Vec<ConversationSummary> = self.conversations.values()
                .map(|conv| ConversationSummary {
                    id: conv.id.clone(),
                    participants: conv.participants.clone(),
                    last_updated: conv.last_updated.clone(), // << Keep as string
                })
                .collect(); // [source: 81]

            // Sort summaries by last_updated string (lexicographical should work for ISO format)
             summaries.sort_by(|a, b| b.last_updated.cmp(&a.last_updated)); // [source: 82]

             Ok(summaries) // [source: 83]
        }
        ```

    * **`GetMessages` (`#[http]` Handler):**
        * Accept `conversation_id: String` [source: 84].
        * Find conversation in `self.conversations` [source: 85].
        * Return `Result<Vec<ChatMessage>, String>` [source: 86]. The `ChatMessage` structs already use `String` for timestamps.

        ```rust
        #[http]
        async fn get_messages(&self, conversation_id: String) -> Result<Vec<ChatMessage>, String> { // [source: 87]
             println!("get_messages called for conversation: {}", conversation_id);
             match self.conversations.get(&conversation_id) {
                 Some(conversation) => Ok(conversation.messages.clone()), // Messages already have string timestamps
                 None => Err(format!("Conversation with ID {} not found", conversation_id)),
             }
        }
        ```

7.  **Add Dependencies (`samchat/Cargo.toml`):**
    * Ensure `uuid` (with `v4`, `serde` features) [source: 89], `chrono` (with `serde` feature) [source: 90], `serde`, `serde_json` are present.
    * Ensure `hyperprocess-macro` and `hyperware-process-lib` are present [source: 89].

    ```toml
    [dependencies]
    # ... other dependencies
    hyperprocess-macro = { path = "../hyperprocess-macro" } # Adjust path if needed [source: 90]
    hyperware-process-lib = { path = "../hyperware-process-lib" } # Adjust path if needed [source: 90]
    serde = { version = "1.0", features = ["derive"] } # [source: 89]
    serde_json = "1.0" # [source: 89]
    uuid = { version = "1.8", features = ["v4", "serde"] } # [source: 89]
    chrono = { version = "0.4", features = ["serde"] } # [source: 90]
    # ...
    ```

### Phase 2: Frontend Modifications (`ui/src/`)

1.  **Update Types (`ui/src/types/samchat.ts`):**
    * Remove `TodoItem` types [source: 91].
    * Define `ChatMessage`, `Conversation`, `ConversationSummary` interfaces. Ensure timestamp fields (`timestamp`, `last_updated`) are explicitly typed as `string` [source: 92, 93].
    * Define request/response types matching the backend handlers [source: 94, 95].

    ```typescript
    // Example:
    export interface ChatMessage {
      id: string;
      conversation_id: string;
      sender: string;
      recipient: string;
      content: string;
      timestamp: string; // << Ensure this is string
      delivered: boolean;
    }

    export interface ConversationSummary {
      id: string;
      participants: string[];
      last_updated: string; // << Ensure this is string
    }
    // ... other types
    ```

2.  **Update State Management (`ui/src/store/samchat.ts`):**
    * Modify Zustand store (`useSamchatStore`) [source: 96].
    * State shape: `conversations: ConversationSummary[]`, `currentConversationMessages: ChatMessage[]`, `currentConversationId: string | null`, `myNodeId: string | null` [source: 97].
    * Update actions: `setConversations`, `setCurrentConversation`, `addMessageToCurrentConversation`, `setMyNodeId`. Ensure they handle the `string` timestamp fields correctly [source: 98]. When adding/sorting messages, compare the timestamp strings directly (lexicographical sort should work for ISO format).

3.  **Update UI Components (`ui/src/App.tsx`, etc.):**
    * Adapt `App.tsx` for chat layout (sidebar, message panel, input) [source: 99, 100, 101].
    * **Conversation List:** Fetch conversations (`GetConversations`) [source: 102]. Render list using `ConversationSummary` (display `last_updated` string appropriately) [source: 103]. Handle selection [source: 104].
    * **Message List:** Display `currentConversationMessages` [source: 105]. Format and display the `timestamp` string nicely (e.g., using `new Date(timestamp).toLocaleString()`) [source: 118]. Style sent/received messages [source: 105].
    * **Message Input:** Handle input for recipient (new convo) and message [source: 106, 107]. On send, call backend `SendMessage` [source: 108, 109]. Consider optimistic UI update [source: 110].

4.  **Implement API Calls (`ui/src/api.ts` or similar):**
    * Create helpers to POST to `/api/send_message`, `/api/get_conversations`, `/api/get_messages` [source: 111]. Ensure request bodies match the defined TypeScript types [source: 112].
    * Implement periodic polling (`setInterval`) to refresh conversations and messages [source: 113].

5.  **Update Styling (`ui/src/App.css`, `ui/src/index.css`):**
    * Remove todo styles [source: 114]. Add chat-specific styles [source: 115].

### Phase 3: Refinement

1.  **Error Handling:** Improve error handling on both backend and frontend [source: 116].
2.  **Conversation ID:** Ensure robust `conversation_id` logic [source: 117].
3.  **Timestamp Handling:** Double-check timestamp string formatting (RFC3339) and display in UI [source: 118].
4.  **UI/UX:** Refine the interface [source: 119].